{"ast":null,"code":"\"use strict\";\n\nvar _objectWithoutPropertiesLoose = require(\"@babel/runtime/helpers/objectWithoutPropertiesLoose\");\nconst _excluded = [\"screen\", \"if\"],\n  _excluded2 = [\"screens\", \"groups\"],\n  _excluded3 = [\"if\"];\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createComponentForStaticNavigation = createComponentForStaticNavigation;\nexports.createPathConfigForStaticNavigation = createPathConfigForStaticNavigation;\nvar _react = _interopRequireWildcard(require(\"react\"));\nvar React = _react;\nvar _reactIs = require(\"react-is\");\nvar _useRoute = require(\"./useRoute.js\");\nvar _jsxRuntime = require(\"react/jsx-runtime\");\nfunction _getRequireWildcardCache(e) {\n  if (\"function\" != typeof WeakMap) return null;\n  var r = new WeakMap(),\n    t = new WeakMap();\n  return (_getRequireWildcardCache = function (e) {\n    return e ? t : r;\n  })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n  if (!r && e && e.__esModule) return e;\n  if (null === e || \"object\" != typeof e && \"function\" != typeof e) return {\n    default: e\n  };\n  var t = _getRequireWildcardCache(r);\n  if (t && t.has(e)) return t.get(e);\n  var n = {\n      __proto__: null\n    },\n    a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) {\n    var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n    i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n  }\n  return n.default = e, t && t.set(e, n), n;\n}\nconst MemoizedScreen = React.memo(({\n  component\n}) => {\n  const route = (0, _useRoute.useRoute)();\n  const children = React.createElement(component, {\n    route\n  });\n  return children;\n});\nMemoizedScreen.displayName = 'Memo(Screen)';\nconst getItemsFromScreens = (Screen, screens) => {\n  return Object.entries(screens).map(([name, item]) => {\n    let component;\n    let props = {};\n    let useIf;\n    let isNavigator = false;\n    if ('screen' in item) {\n      const {\n          screen,\n          if: _if\n        } = item,\n        rest = _objectWithoutPropertiesLoose(item, _excluded);\n      useIf = _if;\n      props = rest;\n      if ((0, _reactIs.isValidElementType)(screen)) {\n        component = screen;\n      } else if ('config' in screen) {\n        isNavigator = true;\n        component = createComponentForStaticNavigation(screen, `${name}Navigator`);\n      }\n    } else if ((0, _reactIs.isValidElementType)(item)) {\n      component = item;\n    } else if ('config' in item) {\n      isNavigator = true;\n      component = createComponentForStaticNavigation(item, `${name}Navigator`);\n    }\n    if (component == null) {\n      throw new Error(`Couldn't find a 'screen' property for the screen '${name}'. This can happen if you passed 'undefined'. You likely forgot to export your component from the file it's defined in, or mixed up default import and named import when importing.`);\n    }\n    const element = isNavigator ? (React.createElement(component, {})) : (0, _jsxRuntime.jsx)(MemoizedScreen, {\n      component: component\n    });\n    return () => {\n      const shouldRender = useIf == null || useIf();\n      if (!shouldRender) {\n        return null;\n      }\n      return (0, _jsxRuntime.jsx)(Screen, Object.assign({\n        name: name\n      }, props, {\n        children: () => element\n      }), name);\n    };\n  });\n};\nfunction createComponentForStaticNavigation(tree, displayName) {\n  const {\n    Navigator,\n    Group,\n    Screen,\n    config\n  } = tree;\n  const {\n      screens,\n      groups\n    } = config,\n    rest = _objectWithoutPropertiesLoose(config, _excluded2);\n  if (screens == null && groups == null) {\n    throw new Error(\"Couldn't find a 'screens' or 'groups' property. Make sure to define your screens under a 'screens' property in the configuration.\");\n  }\n  const items = [];\n  for (const key in config) {\n    if (key === 'screens' && screens) {\n      items.push(...getItemsFromScreens(Screen, screens));\n    }\n    if (key === 'groups' && groups) {\n      items.push(...Object.entries(groups).map(([key, _ref]) => {\n        let {\n            if: useIf\n          } = _ref,\n          group = _objectWithoutPropertiesLoose(_ref, _excluded3);\n        const groupItems = getItemsFromScreens(Screen, group.screens);\n        return () => {\n          const children = groupItems.map(item => item());\n          const shouldRender = useIf == null || useIf();\n          if (!shouldRender) {\n            return null;\n          }\n          return (0, _react.createElement)(Group, Object.assign({\n            navigationKey: key\n          }, group, {\n            key: key\n          }), children);\n        };\n      }));\n    }\n  }\n  const NavigatorComponent = () => {\n    const children = items.map(item => item());\n    return (0, _jsxRuntime.jsx)(Navigator, Object.assign({}, rest, {\n      children: children\n    }));\n  };\n  NavigatorComponent.displayName = displayName;\n  return NavigatorComponent;\n}\nfunction createPathConfigForStaticNavigation(tree, options, auto) {\n  let initialScreenConfig;\n  const createPathConfigForTree = (t, o, skipInitialDetection) => {\n    const createPathConfigForScreens = (screens, initialRouteName) => {\n      return Object.fromEntries(Object.entries(screens).sort(([a], [b]) => {\n        if (a === initialRouteName) {\n          return -1;\n        }\n        if (b === initialRouteName) {\n          return 1;\n        }\n        return 0;\n      }).map(([key, item]) => {\n        const screenConfig = {};\n        if ('linking' in item) {\n          if (typeof item.linking === 'string') {\n            screenConfig.path = item.linking;\n          } else {\n            Object.assign(screenConfig, item.linking);\n          }\n          if (typeof screenConfig.path === 'string') {\n            screenConfig.path = screenConfig.path.replace(/^\\//, '').replace(/\\/$/, '');\n          }\n        }\n        let screens;\n        const skipInitialDetectionInChild = skipInitialDetection || screenConfig.path != null && screenConfig.path !== '';\n        if ('config' in item) {\n          screens = createPathConfigForTree(item, undefined, skipInitialDetectionInChild);\n        } else if ('screen' in item && 'config' in item.screen && (item.screen.config.screens || item.screen.config.groups)) {\n          screens = createPathConfigForTree(item.screen, undefined, skipInitialDetectionInChild);\n        }\n        if (screens) {\n          screenConfig.screens = screens;\n        }\n        if (auto && !screenConfig.screens && !('linking' in item && item.linking == null)) {\n          if (screenConfig.path != null) {\n            if (!skipInitialDetection && screenConfig.path === '') {\n              initialScreenConfig = undefined;\n            }\n          } else {\n            if (!skipInitialDetection && initialScreenConfig == null) {\n              initialScreenConfig = screenConfig;\n            }\n            screenConfig.path = key.replace(/([A-Z]+)/g, '-$1').replace(/^-/, '').toLowerCase();\n          }\n        }\n        return [key, screenConfig];\n      }).filter(([, screen]) => Object.keys(screen).length > 0));\n    };\n    const screens = {};\n    for (const key in t.config) {\n      if (key === 'screens' && t.config.screens) {\n        Object.assign(screens, createPathConfigForScreens(t.config.screens, o?.initialRouteName ?? t.config.initialRouteName));\n      }\n      if (key === 'groups' && t.config.groups) {\n        Object.entries(t.config.groups).forEach(([, group]) => {\n          Object.assign(screens, createPathConfigForScreens(group.screens, o?.initialRouteName ?? t.config.initialRouteName));\n        });\n      }\n    }\n    if (Object.keys(screens).length === 0) {\n      return undefined;\n    }\n    return screens;\n  };\n  const screens = createPathConfigForTree(tree, options, false);\n  if (auto && initialScreenConfig) {\n    initialScreenConfig.path = '';\n  }\n  return screens;\n}","map":{"version":3,"names":["_react","_interopRequireWildcard","require","React","_reactIs","_useRoute","_jsxRuntime","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","MemoizedScreen","memo","component","route","useRoute","children","createElement","displayName","getItemsFromScreens","Screen","screens","entries","map","name","item","props","useIf","isNavigator","screen","if","_if","rest","_objectWithoutPropertiesLoose","_excluded","isValidElementType","createComponentForStaticNavigation","Error","element","jsx","shouldRender","assign","tree","Navigator","Group","config","groups","_excluded2","items","key","push","_ref","group","_excluded3","groupItems","navigationKey","NavigatorComponent","createPathConfigForStaticNavigation","options","auto","initialScreenConfig","createPathConfigForTree","o","skipInitialDetection","createPathConfigForScreens","initialRouteName","fromEntries","sort","b","screenConfig","linking","path","replace","skipInitialDetectionInChild","undefined","toLowerCase","filter","keys","length","forEach"],"sources":["/app/node_modules/@react-navigation/core/src/StaticNavigation.tsx"],"sourcesContent":["import type { NavigationState, ParamListBase } from '@react-navigation/routers';\nimport * as React from 'react';\nimport { isValidElementType } from 'react-is';\n\nimport type {\n  DefaultNavigatorOptions,\n  EventMapBase,\n  NavigationListBase,\n  NavigatorScreenParams,\n  NavigatorTypeBagBase,\n  PathConfig,\n  RouteConfigComponent,\n  RouteConfigProps,\n  RouteGroupConfig,\n} from './types';\nimport { useRoute } from './useRoute';\n\n/**\n * Flatten a type to remove all type alias names, unions etc.\n * This will show a plain object when hovering over the type.\n */\ntype FlatType<T> = { [K in keyof T]: T[K] } & {};\n\n/**\n * keyof T doesn't work for union types. We can use distributive conditional types instead.\n * https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\n */\ntype KeysOf<T> = T extends {} ? keyof T : never;\n\n/**\n * We get a union type when using keyof, but we want an intersection instead.\n * https://stackoverflow.com/a/50375286/1665026\n */\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I\n) => void\n  ? I\n  : never;\n\ntype UnknownToUndefined<T> = unknown extends T ? undefined : T;\n\ntype ParamsForScreenComponent<T> = T extends {\n  screen: React.ComponentType<{ route: { params: infer P } }>;\n}\n  ? P\n  : T extends React.ComponentType<{ route: { params: infer P } }>\n    ? P\n    : undefined;\n\ntype ParamsForScreen<T> = T extends { screen: StaticNavigation<any, any, any> }\n  ? NavigatorScreenParams<StaticParamList<T['screen']>> | undefined\n  : T extends StaticNavigation<any, any, any>\n    ? NavigatorScreenParams<StaticParamList<T>> | undefined\n    : UnknownToUndefined<ParamsForScreenComponent<T>>;\n\ntype ParamListForScreens<Screens> = {\n  [Key in KeysOf<Screens>]: ParamsForScreen<Screens[Key]>;\n};\n\ntype ParamListForGroups<\n  Groups extends\n    | Readonly<{\n        [key: string]: {\n          screens: StaticConfigScreens<\n            ParamListBase,\n            NavigationState,\n            {},\n            EventMapBase,\n            any\n          >;\n        };\n      }>\n    | undefined,\n> = Groups extends {\n  [key: string]: {\n    screens: StaticConfigScreens<\n      ParamListBase,\n      NavigationState,\n      {},\n      EventMapBase,\n      any\n    >;\n  };\n}\n  ? ParamListForScreens<UnionToIntersection<Groups[keyof Groups]['screens']>>\n  : {};\n\ntype StaticRouteConfig<\n  ParamList extends ParamListBase,\n  RouteName extends keyof ParamList,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  Navigation,\n> = RouteConfigProps<\n  ParamList,\n  RouteName,\n  State,\n  ScreenOptions,\n  EventMap,\n  Navigation\n> &\n  RouteConfigComponent<ParamList, RouteName>;\n\ntype StaticConfigScreens<\n  ParamList extends ParamListBase,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  NavigationList extends NavigationListBase<ParamList>,\n> = {\n  [RouteName in keyof ParamList]:\n    | React.ComponentType<any>\n    | StaticNavigation<any, any, any>\n    | (Omit<\n        StaticRouteConfig<\n          ParamList,\n          RouteName,\n          State,\n          ScreenOptions,\n          EventMap,\n          NavigationList[RouteName]\n        >,\n        'name' | 'component' | 'getComponent' | 'children'\n      > & {\n        /**\n         * Callback to determine whether the screen should be rendered or not.\n         * This can be useful for conditional rendering of screens,\n         * e.g. - if you want to render a different screen for logged in users.\n         *\n         * You can use a custom hook to use custom logic to determine the return value.\n         *\n         * @example\n         * ```js\n         * if: useIsLoggedIn\n         * ```\n         */\n        if?: () => boolean;\n        /**\n         * Linking config for the screen.\n         * This can be a string to specify the path, or an object with more options.\n         *\n         * @example\n         * ```js\n         * linking: {\n         *   path: 'profile/:id',\n         *   exact: true,\n         * },\n         * ```\n         */\n        linking?: PathConfig<ParamList> | string;\n        /**\n         * Static navigation config or Component to render for the screen.\n         */\n        screen: StaticNavigation<any, any, any> | React.ComponentType<any>;\n      });\n};\n\ntype GroupConfig<\n  ParamList extends ParamListBase,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  NavigationList extends NavigationListBase<ParamList>,\n> = Omit<\n  RouteGroupConfig<ParamList, ScreenOptions, NavigationList[keyof ParamList]>,\n  'screens' | 'children'\n> & {\n  /**\n   * Callback to determine whether the screens in the group should be rendered or not.\n   * This can be useful for conditional rendering of group of screens.\n   */\n  if?: () => boolean;\n  /**\n   * Static navigation config or Component to render for the screen.\n   */\n  screens: StaticConfigScreens<\n    ParamList,\n    State,\n    ScreenOptions,\n    EventMap,\n    NavigationList\n  >;\n};\n\nexport type StaticConfig<Bag extends NavigatorTypeBagBase> =\n  StaticConfigInternal<\n    Bag['ParamList'],\n    Bag['NavigatorID'],\n    Bag['State'],\n    Bag['ScreenOptions'],\n    Bag['EventMap'],\n    Bag['NavigationList'],\n    Bag['Navigator']\n  >;\n\ntype StaticConfigInternal<\n  ParamList extends ParamListBase,\n  NavigatorID extends string | undefined,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  NavigationList extends NavigationListBase<ParamList>,\n  Navigator extends React.ComponentType<any>,\n> = Omit<\n  Omit<\n    React.ComponentProps<Navigator>,\n    keyof DefaultNavigatorOptions<\n      ParamListBase,\n      string | undefined,\n      NavigationState,\n      {},\n      EventMapBase,\n      NavigationList[keyof ParamList]\n    >\n  > &\n    DefaultNavigatorOptions<\n      ParamList,\n      NavigatorID,\n      State,\n      ScreenOptions,\n      EventMap,\n      NavigationList[keyof ParamList]\n    >,\n  'screens' | 'children'\n> &\n  (\n    | {\n        /**\n         * Screens to render in the navigator and their configuration.\n         */\n        screens: StaticConfigScreens<\n          ParamList,\n          State,\n          ScreenOptions,\n          EventMap,\n          NavigationList\n        >;\n        /**\n         * Groups of screens to render in the navigator and their configuration.\n         */\n        groups?: {\n          [key: string]: GroupConfig<\n            ParamList,\n            State,\n            ScreenOptions,\n            EventMap,\n            NavigationList\n          >;\n        };\n      }\n    | {\n        /**\n         * Screens to render in the navigator and their configuration.\n         */\n        screens?: StaticConfigScreens<\n          ParamList,\n          State,\n          ScreenOptions,\n          EventMap,\n          NavigationList\n        >;\n        /**\n         * Groups of screens to render in the navigator and their configuration.\n         */\n        groups: {\n          [key: string]: GroupConfig<\n            ParamList,\n            State,\n            ScreenOptions,\n            EventMap,\n            NavigationList\n          >;\n        };\n      }\n  );\n\n/**\n * Props for a screen component which is rendered by a static navigator.\n * Takes the route params as a generic argument.\n */\nexport type StaticScreenProps<T extends Record<string, unknown> | undefined> = {\n  route: {\n    params: T;\n  };\n};\n\n/**\n * Infer the param list from the static navigation config.\n */\nexport type StaticParamList<\n  T extends {\n    readonly config: {\n      readonly screens?: Record<string, any>;\n      readonly groups?: {\n        [key: string]: {\n          screens: Record<string, any>;\n        };\n      };\n    };\n  },\n> = FlatType<\n  ParamListForScreens<T['config']['screens']> &\n    ParamListForGroups<T['config']['groups']>\n>;\n\nexport type StaticNavigation<NavigatorProps, GroupProps, ScreenProps> = {\n  Navigator: React.ComponentType<NavigatorProps>;\n  Group: React.ComponentType<GroupProps>;\n  Screen: React.ComponentType<ScreenProps>;\n  config: StaticConfig<NavigatorTypeBagBase>;\n};\n\nconst MemoizedScreen = React.memo(\n  <T extends React.ComponentType<any>>({ component }: { component: T }) => {\n    const route = useRoute();\n    const children = React.createElement(component, { route });\n\n    return children;\n  }\n);\n\nMemoizedScreen.displayName = 'Memo(Screen)';\n\nconst getItemsFromScreens = (\n  Screen: React.ComponentType<any>,\n  screens: StaticConfigScreens<any, any, any, any, any>\n) => {\n  return Object.entries(screens).map(([name, item]) => {\n    let component: React.ComponentType<any> | undefined;\n    let props: {} = {};\n    let useIf: (() => boolean) | undefined;\n\n    let isNavigator = false;\n\n    if ('screen' in item) {\n      const { screen, if: _if, ...rest } = item;\n\n      useIf = _if;\n      props = rest;\n\n      if (isValidElementType(screen)) {\n        component = screen;\n      } else if ('config' in screen) {\n        isNavigator = true;\n        component = createComponentForStaticNavigation(\n          screen,\n          `${name}Navigator`\n        );\n      }\n    } else if (isValidElementType(item)) {\n      component = item;\n    } else if ('config' in item) {\n      isNavigator = true;\n      component = createComponentForStaticNavigation(item, `${name}Navigator`);\n    }\n\n    if (component == null) {\n      throw new Error(\n        `Couldn't find a 'screen' property for the screen '${name}'. This can happen if you passed 'undefined'. You likely forgot to export your component from the file it's defined in, or mixed up default import and named import when importing.`\n      );\n    }\n\n    const element = isNavigator ? (\n      React.createElement(component, {})\n    ) : (\n      <MemoizedScreen component={component} />\n    );\n\n    return () => {\n      const shouldRender = useIf == null || useIf();\n\n      if (!shouldRender) {\n        return null;\n      }\n\n      return (\n        <Screen key={name} name={name} {...props}>\n          {() => element}\n        </Screen>\n      );\n    };\n  });\n};\n\n/**\n * Create a component that renders a navigator based on the static configuration.\n *\n * @param tree Static navigation config.\n * @param displayName Name of the component to be displayed in React DevTools.\n * @returns A component which renders the navigator.\n */\nexport function createComponentForStaticNavigation(\n  tree: StaticNavigation<any, any, any>,\n  displayName: string\n): React.ComponentType<{}> {\n  const { Navigator, Group, Screen, config } = tree;\n  const { screens, groups, ...rest } = config;\n\n  if (screens == null && groups == null) {\n    throw new Error(\n      \"Couldn't find a 'screens' or 'groups' property. Make sure to define your screens under a 'screens' property in the configuration.\"\n    );\n  }\n\n  const items: (() => JSX.Element | null)[] = [];\n\n  // Loop through the config to find screens and groups\n  // So we add the screens and groups in the same order as they are defined\n  for (const key in config) {\n    if (key === 'screens' && screens) {\n      items.push(...getItemsFromScreens(Screen, screens));\n    }\n\n    if (key === 'groups' && groups) {\n      items.push(\n        ...Object.entries(groups).map(([key, { if: useIf, ...group }]) => {\n          const groupItems = getItemsFromScreens(Screen, group.screens);\n\n          return () => {\n            // Call unconditionally since screen configs may contain `useIf` hooks\n            const children = groupItems.map((item) => item());\n\n            const shouldRender = useIf == null || useIf();\n\n            if (!shouldRender) {\n              return null;\n            }\n\n            return (\n              <Group navigationKey={key} {...group} key={key}>\n                {children}\n              </Group>\n            );\n          };\n        })\n      );\n    }\n  }\n\n  const NavigatorComponent = () => {\n    const children = items.map((item) => item());\n\n    return <Navigator {...rest}>{children}</Navigator>;\n  };\n\n  NavigatorComponent.displayName = displayName;\n\n  return NavigatorComponent;\n}\n\ntype TreeForPathConfig = {\n  config: {\n    initialRouteName?: string;\n    screens?: StaticConfigScreens<\n      ParamListBase,\n      NavigationState,\n      {},\n      EventMapBase,\n      Record<string, unknown>\n    >;\n    groups?: {\n      [key: string]: {\n        screens: StaticConfigScreens<\n          ParamListBase,\n          NavigationState,\n          {},\n          EventMapBase,\n          Record<string, unknown>\n        >;\n      };\n    };\n  };\n};\n\n/**\n * Create a path config object from a static navigation config for deep linking.\n *\n * @param tree Static navigation config.\n * @param options Additional options from `linking.config`.\n * @param auto Whether to automatically generate paths for leaf screens.\n * @returns Path config object to use in linking config.\n *\n * @example\n * ```js\n * const config = {\n *   screens: {\n *     Home: {\n *       screens: createPathConfigForStaticNavigation(HomeTabs),\n *     },\n *   },\n * };\n * ```\n */\nexport function createPathConfigForStaticNavigation(\n  tree: TreeForPathConfig,\n  options?: {\n    initialRouteName?: string;\n  },\n  auto?: boolean\n) {\n  let initialScreenConfig: PathConfig<ParamListBase> | undefined;\n\n  const createPathConfigForTree = (\n    t: TreeForPathConfig,\n    o: { initialRouteName?: string } | undefined,\n    // If a screen is a leaf node, but inside a screen with path,\n    // It should not be used for initial detection\n    skipInitialDetection: boolean\n  ) => {\n    const createPathConfigForScreens = (\n      screens: StaticConfigScreens<\n        ParamListBase,\n        NavigationState,\n        {},\n        EventMapBase,\n        Record<string, unknown>\n      >,\n      initialRouteName: string | undefined\n    ) => {\n      return Object.fromEntries(\n        Object.entries(screens)\n          // Re-order to move the initial route to the front\n          // This way we can detect the initial route correctly\n          .sort(([a], [b]) => {\n            if (a === initialRouteName) {\n              return -1;\n            }\n\n            if (b === initialRouteName) {\n              return 1;\n            }\n\n            return 0;\n          })\n          .map(([key, item]) => {\n            const screenConfig: PathConfig<ParamListBase> = {};\n\n            if ('linking' in item) {\n              if (typeof item.linking === 'string') {\n                screenConfig.path = item.linking;\n              } else {\n                Object.assign(screenConfig, item.linking);\n              }\n\n              if (typeof screenConfig.path === 'string') {\n                screenConfig.path = screenConfig.path\n                  .replace(/^\\//, '') // Remove extra leading slash\n                  .replace(/\\/$/, ''); // Remove extra trailing slash\n              }\n            }\n\n            let screens;\n\n            const skipInitialDetectionInChild =\n              skipInitialDetection ||\n              (screenConfig.path != null && screenConfig.path !== '');\n\n            if ('config' in item) {\n              screens = createPathConfigForTree(\n                item,\n                undefined,\n                skipInitialDetectionInChild\n              );\n            } else if (\n              'screen' in item &&\n              'config' in item.screen &&\n              (item.screen.config.screens || item.screen.config.groups)\n            ) {\n              screens = createPathConfigForTree(\n                item.screen,\n                undefined,\n                skipInitialDetectionInChild\n              );\n            }\n\n            if (screens) {\n              screenConfig.screens = screens;\n            }\n\n            if (\n              auto &&\n              !screenConfig.screens &&\n              // Skip generating path for screens that specify linking config as `undefined` or `null` explicitly\n              !('linking' in item && item.linking == null)\n            ) {\n              if (screenConfig.path != null) {\n                if (!skipInitialDetection && screenConfig.path === '') {\n                  // We encounter a leaf screen with empty path,\n                  // Clear the initial screen config as it's not needed anymore\n                  initialScreenConfig = undefined;\n                }\n              } else {\n                if (!skipInitialDetection && initialScreenConfig == null) {\n                  initialScreenConfig = screenConfig;\n                }\n\n                screenConfig.path = key\n                  .replace(/([A-Z]+)/g, '-$1')\n                  .replace(/^-/, '')\n                  .toLowerCase();\n              }\n            }\n\n            return [key, screenConfig] as const;\n          })\n          .filter(([, screen]) => Object.keys(screen).length > 0)\n      );\n    };\n\n    const screens = {};\n\n    // Loop through the config to find screens and groups\n    // So we add the screens and groups in the same order as they are defined\n    for (const key in t.config) {\n      if (key === 'screens' && t.config.screens) {\n        Object.assign(\n          screens,\n          createPathConfigForScreens(\n            t.config.screens,\n            o?.initialRouteName ?? t.config.initialRouteName\n          )\n        );\n      }\n\n      if (key === 'groups' && t.config.groups) {\n        Object.entries(t.config.groups).forEach(([, group]) => {\n          Object.assign(\n            screens,\n            createPathConfigForScreens(\n              group.screens,\n              o?.initialRouteName ?? t.config.initialRouteName\n            )\n          );\n        });\n      }\n    }\n\n    if (Object.keys(screens).length === 0) {\n      return undefined;\n    }\n\n    return screens;\n  };\n\n  const screens = createPathConfigForTree(tree, options, false);\n\n  if (auto && initialScreenConfig) {\n    initialScreenConfig.path = '';\n  }\n\n  return screens;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":true},"sourceType":"script","externalDependencies":[]}