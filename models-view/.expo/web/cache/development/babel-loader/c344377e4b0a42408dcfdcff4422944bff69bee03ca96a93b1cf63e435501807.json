{"ast":null,"code":"'use client';\n\nvar _jsxFileName = \"/app/node_modules/@expo/metro-runtime/src/error-overlay/Data/LogBoxData.tsx\";\nimport * as React from 'react';\nimport NativeEventEmitter from \"react-native-web/dist/exports/NativeEventEmitter\";\nimport { LogBoxLog } from './LogBoxLog';\nimport { LogContext } from './LogContext';\nimport { parseLogBoxException } from './parseLogBoxLog';\nimport NativeLogBox from '../modules/NativeLogBox';\nimport parseErrorStack from '../modules/parseErrorStack';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst observers = new Set();\nconst ignorePatterns = new Set();\nlet logs = new Set();\nlet updateTimeout = null;\nlet _isDisabled = false;\nlet _selectedIndex = -1;\nconst LOGBOX_ERROR_MESSAGE = 'An error was thrown when attempting to render log messages via LogBox.';\nfunction getNextState() {\n  return {\n    logs,\n    isDisabled: _isDisabled,\n    selectedLogIndex: _selectedIndex\n  };\n}\nexport function reportLogBoxError(error, componentStack) {\n  const ExceptionsManager = require('../modules/ExceptionsManager').default;\n  if (componentStack != null) {\n    error.componentStack = componentStack;\n  }\n  ExceptionsManager.handleException(error);\n}\nexport function reportUnexpectedLogBoxError(error, componentStack) {\n  error.message = `${LOGBOX_ERROR_MESSAGE}\\n\\n${error.message}`;\n  return reportLogBoxError(error, componentStack);\n}\nexport function isLogBoxErrorMessage(message) {\n  return typeof message === 'string' && message.includes(LOGBOX_ERROR_MESSAGE);\n}\nexport function isMessageIgnored(message) {\n  for (const pattern of ignorePatterns) {\n    if (pattern instanceof RegExp && pattern.test(message) || typeof pattern === 'string' && message.includes(pattern)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction setImmediateShim(callback) {\n  if (!global.setImmediate) {\n    return setTimeout(callback, 0);\n  }\n  return global.setImmediate(callback);\n}\nfunction handleUpdate() {\n  if (updateTimeout == null) {\n    updateTimeout = setImmediateShim(() => {\n      updateTimeout = null;\n      const nextState = getNextState();\n      observers.forEach(({\n        observer\n      }) => observer(nextState));\n    });\n  }\n}\nfunction appendNewLog(newLog) {\n  if (isMessageIgnored(newLog.message.content)) {\n    return;\n  }\n  const lastLog = Array.from(logs).pop();\n  if (lastLog && lastLog.category === newLog.category) {\n    lastLog.incrementCount();\n    handleUpdate();\n    return;\n  }\n  if (newLog.level === 'fatal') {\n    const OPTIMISTIC_WAIT_TIME = 1000;\n    let addPendingLog = () => {\n      logs.add(newLog);\n      if (_selectedIndex < 0) {\n        setSelectedLog(logs.size - 1);\n      } else {\n        handleUpdate();\n      }\n      addPendingLog = null;\n    };\n    const optimisticTimeout = setTimeout(() => {\n      if (addPendingLog) {\n        addPendingLog();\n      }\n    }, OPTIMISTIC_WAIT_TIME);\n    newLog.symbolicate('component');\n    newLog.symbolicate('stack', status => {\n      if (addPendingLog && status !== 'PENDING') {\n        addPendingLog();\n        clearTimeout(optimisticTimeout);\n      } else if (status !== 'PENDING') {\n        handleUpdate();\n      }\n    });\n  } else if (newLog.level === 'syntax') {\n    logs.add(newLog);\n    setSelectedLog(logs.size - 1);\n  } else {\n    logs.add(newLog);\n    handleUpdate();\n  }\n}\nexport function addLog(log) {\n  const errorForStackTrace = new Error();\n  setImmediate(() => {\n    try {\n      const stack = parseErrorStack(errorForStackTrace?.stack);\n      appendNewLog(new LogBoxLog({\n        level: log.level,\n        message: log.message,\n        isComponentError: false,\n        stack,\n        category: log.category,\n        componentStack: log.componentStack\n      }));\n    } catch (error) {\n      reportUnexpectedLogBoxError(error);\n    }\n  });\n}\nexport function addException(error) {\n  setImmediate(() => {\n    try {\n      appendNewLog(new LogBoxLog(parseLogBoxException(error)));\n    } catch (loggingError) {\n      reportUnexpectedLogBoxError(loggingError);\n    }\n  });\n}\nexport function symbolicateLogNow(type, log) {\n  log.symbolicate(type, () => {\n    handleUpdate();\n  });\n}\nexport function retrySymbolicateLogNow(type, log) {\n  log.retrySymbolicate(type, () => {\n    handleUpdate();\n  });\n}\nexport function symbolicateLogLazy(type, log) {\n  log.symbolicate(type);\n}\nexport function clear() {\n  if (logs.size > 0) {\n    logs = new Set();\n    setSelectedLog(-1);\n  }\n}\nexport function setSelectedLog(proposedNewIndex) {\n  const oldIndex = _selectedIndex;\n  let newIndex = proposedNewIndex;\n  const logArray = Array.from(logs);\n  let index = logArray.length - 1;\n  while (index >= 0) {\n    if (logArray[index].level === 'syntax') {\n      newIndex = index;\n      break;\n    }\n    index -= 1;\n  }\n  _selectedIndex = newIndex;\n  handleUpdate();\n  if (NativeLogBox) {\n    setTimeout(() => {\n      if (oldIndex < 0 && newIndex >= 0) {\n        NativeLogBox.show();\n      } else if (oldIndex >= 0 && newIndex < 0) {\n        NativeLogBox.hide();\n      }\n    }, 0);\n  }\n}\nexport function clearWarnings() {\n  const newLogs = Array.from(logs).filter(log => log.level !== 'warn');\n  if (newLogs.length !== logs.size) {\n    logs = new Set(newLogs);\n    setSelectedLog(-1);\n    handleUpdate();\n  }\n}\nexport function clearErrors() {\n  const newLogs = Array.from(logs).filter(log => log.level !== 'error' && log.level !== 'fatal');\n  if (newLogs.length !== logs.size) {\n    logs = new Set(newLogs);\n    setSelectedLog(-1);\n  }\n}\nexport function dismiss(log) {\n  if (logs.has(log)) {\n    logs.delete(log);\n    handleUpdate();\n  }\n}\nexport function getIgnorePatterns() {\n  return Array.from(ignorePatterns);\n}\nexport function addIgnorePatterns(patterns) {\n  const existingSize = ignorePatterns.size;\n  patterns.forEach(pattern => {\n    if (pattern instanceof RegExp) {\n      for (const existingPattern of ignorePatterns) {\n        if (existingPattern instanceof RegExp && existingPattern.toString() === pattern.toString()) {\n          return;\n        }\n      }\n      ignorePatterns.add(pattern);\n    }\n    ignorePatterns.add(pattern);\n  });\n  if (ignorePatterns.size === existingSize) {\n    return;\n  }\n  logs = new Set(Array.from(logs).filter(log => !isMessageIgnored(log.message.content)));\n  handleUpdate();\n}\nexport function setDisabled(value) {\n  if (value === _isDisabled) {\n    return;\n  }\n  _isDisabled = value;\n  handleUpdate();\n}\nexport function isDisabled() {\n  return _isDisabled;\n}\nexport function observe(observer) {\n  const subscription = {\n    observer\n  };\n  observers.add(subscription);\n  observer(getNextState());\n  return {\n    unsubscribe() {\n      observers.delete(subscription);\n    }\n  };\n}\nconst emitter = new NativeEventEmitter({\n  addListener() {},\n  removeListeners() {}\n});\nexport function withSubscription(WrappedComponent) {\n  class LogBoxStateSubscription extends React.Component {\n    static getDerivedStateFromError() {\n      return {\n        hasError: true\n      };\n    }\n    constructor(props) {\n      super(props);\n      if (process.env.NODE_ENV === 'development') {\n        emitter.addListener('devLoadingView:hide', () => {\n          if (this.state.hasError) {\n            this.retry();\n          }\n        });\n      }\n    }\n    componentDidCatch(err, errorInfo) {\n      reportLogBoxError(err, errorInfo.componentStack);\n    }\n    state = {\n      logs: new Set(),\n      isDisabled: false,\n      hasError: false,\n      selectedLogIndex: -1\n    };\n    retry = () => {\n      return new Promise(resolve => {\n        this.setState({\n          hasError: false\n        }, () => {\n          resolve();\n        });\n      });\n    };\n    render() {\n      return _jsxDEV(LogContext.Provider, {\n        value: {\n          selectedLogIndex: this.state.selectedLogIndex,\n          isDisabled: this.state.isDisabled,\n          logs: Array.from(this.state.logs)\n        },\n        children: [this.state.hasError ? null : this.props.children, _jsxDEV(WrappedComponent, {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 415,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 408,\n        columnNumber: 9\n      }, this);\n    }\n    componentDidMount() {\n      this._subscription = observe(data => {\n        if (data.selectedLogIndex === -1) return;\n        React.startTransition(() => {\n          this.setState(data);\n        });\n      });\n    }\n    componentWillUnmount() {\n      if (this._subscription != null) {\n        this._subscription.unsubscribe();\n      }\n    }\n    _handleDismiss = () => {\n      const {\n        selectedLogIndex,\n        logs: stateLogs\n      } = this.state;\n      const logsArray = Array.from(stateLogs);\n      if (selectedLogIndex != null) {\n        if (logsArray.length - 1 <= 0) {\n          setSelectedLog(-1);\n        } else if (selectedLogIndex >= logsArray.length - 1) {\n          setSelectedLog(selectedLogIndex - 1);\n        }\n        dismiss(logsArray[selectedLogIndex]);\n      }\n    };\n    _handleMinimize = () => {\n      setSelectedLog(-1);\n    };\n    _handleSetSelectedLog = index => {\n      setSelectedLog(index);\n    };\n  }\n  return LogBoxStateSubscription;\n}","map":{"version":3,"names":["_jsxFileName","React","NativeEventEmitter","LogBoxLog","LogContext","parseLogBoxException","NativeLogBox","parseErrorStack","jsxDEV","_jsxDEV","observers","Set","ignorePatterns","logs","updateTimeout","_isDisabled","_selectedIndex","LOGBOX_ERROR_MESSAGE","getNextState","isDisabled","selectedLogIndex","reportLogBoxError","error","componentStack","ExceptionsManager","require","default","handleException","reportUnexpectedLogBoxError","message","isLogBoxErrorMessage","includes","isMessageIgnored","pattern","RegExp","test","setImmediateShim","callback","global","setImmediate","setTimeout","handleUpdate","nextState","forEach","observer","appendNewLog","newLog","content","lastLog","Array","from","pop","category","incrementCount","level","OPTIMISTIC_WAIT_TIME","addPendingLog","add","setSelectedLog","size","optimisticTimeout","symbolicate","status","clearTimeout","addLog","log","errorForStackTrace","Error","stack","isComponentError","addException","loggingError","symbolicateLogNow","type","retrySymbolicateLogNow","retrySymbolicate","symbolicateLogLazy","clear","proposedNewIndex","oldIndex","newIndex","logArray","index","length","show","hide","clearWarnings","newLogs","filter","clearErrors","dismiss","has","delete","getIgnorePatterns","addIgnorePatterns","patterns","existingSize","existingPattern","toString","setDisabled","value","observe","subscription","unsubscribe","emitter","addListener","removeListeners","withSubscription","WrappedComponent","LogBoxStateSubscription","Component","getDerivedStateFromError","hasError","constructor","props","process","env","NODE_ENV","state","retry","componentDidCatch","err","errorInfo","Promise","resolve","setState","render","Provider","children","fileName","lineNumber","columnNumber","componentDidMount","_subscription","data","startTransition","componentWillUnmount","_handleDismiss","stateLogs","logsArray","_handleMinimize","_handleSetSelectedLog"],"sources":["/app/node_modules/@expo/metro-runtime/src/error-overlay/Data/LogBoxData.tsx"],"sourcesContent":["/**\n * Copyright (c) 650 Industries.\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use client';\n\nimport * as React from 'react';\nimport { NativeEventEmitter } from 'react-native';\n\nimport { LogBoxLog, StackType } from './LogBoxLog';\nimport type { LogLevel } from './LogBoxLog';\nimport { LogContext } from './LogContext';\nimport { parseLogBoxException } from './parseLogBoxLog';\nimport type { Message, Category, ComponentStack, ExtendedExceptionData } from './parseLogBoxLog';\nimport NativeLogBox from '../modules/NativeLogBox';\nimport parseErrorStack from '../modules/parseErrorStack';\n\nexport type LogBoxLogs = Set<LogBoxLog>;\n\nexport type LogData = {\n  level: LogLevel;\n  message: Message;\n  category: Category;\n  componentStack: ComponentStack;\n};\n\ntype ExtendedError = any;\n\nexport type Observer = (options: {\n  logs: LogBoxLogs;\n  isDisabled: boolean;\n  selectedLogIndex: number;\n}) => void;\n\nexport type IgnorePattern = string | RegExp;\n\nexport type Subscription = {\n  unsubscribe: () => void;\n};\n\nexport type WarningInfo = {\n  finalFormat: string;\n  forceDialogImmediately: boolean;\n  suppressDialog_LEGACY: boolean;\n  suppressCompletely: boolean;\n  monitorEvent: string | null;\n  monitorListVersion: number;\n  monitorSampleRate: number;\n};\n\nexport type WarningFilter = (format: string) => WarningInfo;\n\ntype Props = object;\n\ntype State = {\n  logs: LogBoxLogs;\n  isDisabled: boolean;\n  hasError: boolean;\n  selectedLogIndex: number;\n};\n\nconst observers: Set<{ observer: Observer } & any> = new Set();\nconst ignorePatterns: Set<IgnorePattern> = new Set();\nlet logs: LogBoxLogs = new Set();\nlet updateTimeout: null | ReturnType<typeof setImmediate> | ReturnType<typeof setTimeout> = null;\nlet _isDisabled = false;\nlet _selectedIndex = -1;\n\nconst LOGBOX_ERROR_MESSAGE =\n  'An error was thrown when attempting to render log messages via LogBox.';\n\nfunction getNextState() {\n  return {\n    logs,\n    isDisabled: _isDisabled,\n    selectedLogIndex: _selectedIndex,\n  };\n}\n\nexport function reportLogBoxError(error: ExtendedError, componentStack?: string): void {\n  const ExceptionsManager = require('../modules/ExceptionsManager').default;\n\n  if (componentStack != null) {\n    error.componentStack = componentStack;\n  }\n  ExceptionsManager.handleException(error);\n}\n\nexport function reportUnexpectedLogBoxError(error: ExtendedError, componentStack?: string): void {\n  error.message = `${LOGBOX_ERROR_MESSAGE}\\n\\n${error.message}`;\n  return reportLogBoxError(error, componentStack);\n}\n\nexport function isLogBoxErrorMessage(message: string): boolean {\n  return typeof message === 'string' && message.includes(LOGBOX_ERROR_MESSAGE);\n}\n\nexport function isMessageIgnored(message: string): boolean {\n  for (const pattern of ignorePatterns) {\n    if (\n      (pattern instanceof RegExp && pattern.test(message)) ||\n      (typeof pattern === 'string' && message.includes(pattern))\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction setImmediateShim(callback: () => void) {\n  if (!global.setImmediate) {\n    return setTimeout(callback, 0);\n  }\n  return global.setImmediate(callback);\n}\n\nfunction handleUpdate(): void {\n  if (updateTimeout == null) {\n    updateTimeout = setImmediateShim(() => {\n      updateTimeout = null;\n      const nextState = getNextState();\n      observers.forEach(({ observer }) => observer(nextState));\n    });\n  }\n}\n\nfunction appendNewLog(newLog: LogBoxLog): void {\n  // Don't want store these logs because they trigger a\n  // state update when we add them to the store.\n  if (isMessageIgnored(newLog.message.content)) {\n    return;\n  }\n\n  // If the next log has the same category as the previous one\n  // then roll it up into the last log in the list by incrementing\n  // the count (similar to how Chrome does it).\n  const lastLog = Array.from(logs).pop();\n  if (lastLog && lastLog.category === newLog.category) {\n    lastLog.incrementCount();\n    handleUpdate();\n    return;\n  }\n\n  if (newLog.level === 'fatal') {\n    // If possible, to avoid jank, we don't want to open the error before\n    // it's symbolicated. To do that, we optimistically wait for\n    // symbolication for up to a second before adding the log.\n    const OPTIMISTIC_WAIT_TIME = 1000;\n\n    let addPendingLog: null | (() => void) = () => {\n      logs.add(newLog);\n      if (_selectedIndex < 0) {\n        setSelectedLog(logs.size - 1);\n      } else {\n        handleUpdate();\n      }\n      addPendingLog = null;\n    };\n\n    const optimisticTimeout = setTimeout(() => {\n      if (addPendingLog) {\n        addPendingLog();\n      }\n    }, OPTIMISTIC_WAIT_TIME);\n\n    // TODO: HANDLE THIS\n    newLog.symbolicate('component');\n\n    newLog.symbolicate('stack', (status) => {\n      if (addPendingLog && status !== 'PENDING') {\n        addPendingLog();\n        clearTimeout(optimisticTimeout);\n      } else if (status !== 'PENDING') {\n        // The log has already been added but we need to trigger a render.\n        handleUpdate();\n      }\n    });\n  } else if (newLog.level === 'syntax') {\n    logs.add(newLog);\n    setSelectedLog(logs.size - 1);\n  } else {\n    logs.add(newLog);\n    handleUpdate();\n  }\n}\n\nexport function addLog(log: LogData): void {\n  const errorForStackTrace = new Error();\n\n  // Parsing logs are expensive so we schedule this\n  // otherwise spammy logs would pause rendering.\n  setImmediate(() => {\n    try {\n      const stack = parseErrorStack(errorForStackTrace?.stack);\n\n      appendNewLog(\n        new LogBoxLog({\n          level: log.level,\n          message: log.message,\n          isComponentError: false,\n          stack,\n          category: log.category,\n          componentStack: log.componentStack,\n        })\n      );\n    } catch (error) {\n      reportUnexpectedLogBoxError(error);\n    }\n  });\n}\n\nexport function addException(error: ExtendedExceptionData): void {\n  // Parsing logs are expensive so we schedule this\n  // otherwise spammy logs would pause rendering.\n  setImmediate(() => {\n    try {\n      appendNewLog(new LogBoxLog(parseLogBoxException(error)));\n    } catch (loggingError) {\n      reportUnexpectedLogBoxError(loggingError);\n    }\n  });\n}\n\nexport function symbolicateLogNow(type: StackType, log: LogBoxLog) {\n  log.symbolicate(type, () => {\n    handleUpdate();\n  });\n}\n\nexport function retrySymbolicateLogNow(type: StackType, log: LogBoxLog) {\n  log.retrySymbolicate(type, () => {\n    handleUpdate();\n  });\n}\n\nexport function symbolicateLogLazy(type: StackType, log: LogBoxLog) {\n  log.symbolicate(type);\n}\n\nexport function clear(): void {\n  if (logs.size > 0) {\n    logs = new Set();\n    setSelectedLog(-1);\n  }\n}\n\nexport function setSelectedLog(proposedNewIndex: number): void {\n  const oldIndex = _selectedIndex;\n  let newIndex = proposedNewIndex;\n\n  const logArray = Array.from(logs);\n  let index = logArray.length - 1;\n  while (index >= 0) {\n    // The latest syntax error is selected and displayed before all other logs.\n    if (logArray[index].level === 'syntax') {\n      newIndex = index;\n      break;\n    }\n    index -= 1;\n  }\n  _selectedIndex = newIndex;\n  handleUpdate();\n  if (NativeLogBox) {\n    setTimeout(() => {\n      if (oldIndex < 0 && newIndex >= 0) {\n        NativeLogBox.show();\n      } else if (oldIndex >= 0 && newIndex < 0) {\n        NativeLogBox.hide();\n      }\n    }, 0);\n  }\n}\n\nexport function clearWarnings(): void {\n  const newLogs = Array.from(logs).filter((log) => log.level !== 'warn');\n  if (newLogs.length !== logs.size) {\n    logs = new Set(newLogs);\n    setSelectedLog(-1);\n    handleUpdate();\n  }\n}\n\nexport function clearErrors(): void {\n  const newLogs = Array.from(logs).filter((log) => log.level !== 'error' && log.level !== 'fatal');\n  if (newLogs.length !== logs.size) {\n    logs = new Set(newLogs);\n    setSelectedLog(-1);\n  }\n}\n\nexport function dismiss(log: LogBoxLog): void {\n  if (logs.has(log)) {\n    logs.delete(log);\n    handleUpdate();\n  }\n}\n\nexport function getIgnorePatterns(): IgnorePattern[] {\n  return Array.from(ignorePatterns);\n}\n\nexport function addIgnorePatterns(patterns: IgnorePattern[]): void {\n  const existingSize = ignorePatterns.size;\n  // The same pattern may be added multiple times, but adding a new pattern\n  // can be expensive so let's find only the ones that are new.\n  patterns.forEach((pattern: IgnorePattern) => {\n    if (pattern instanceof RegExp) {\n      for (const existingPattern of ignorePatterns) {\n        if (\n          existingPattern instanceof RegExp &&\n          existingPattern.toString() === pattern.toString()\n        ) {\n          return;\n        }\n      }\n      ignorePatterns.add(pattern);\n    }\n    ignorePatterns.add(pattern);\n  });\n  if (ignorePatterns.size === existingSize) {\n    return;\n  }\n  // We need to recheck all of the existing logs.\n  // This allows adding an ignore pattern anywhere in the codebase.\n  // Without this, if you ignore a pattern after the a log is created,\n  // then we would keep showing the log.\n  logs = new Set(Array.from(logs).filter((log) => !isMessageIgnored(log.message.content)));\n  handleUpdate();\n}\n\nexport function setDisabled(value: boolean): void {\n  if (value === _isDisabled) {\n    return;\n  }\n  _isDisabled = value;\n  handleUpdate();\n}\n\nexport function isDisabled(): boolean {\n  return _isDisabled;\n}\n\nexport function observe(observer: Observer): Subscription {\n  const subscription = { observer };\n  observers.add(subscription);\n\n  observer(getNextState());\n\n  return {\n    unsubscribe(): void {\n      observers.delete(subscription);\n    },\n  };\n}\n\nconst emitter = new NativeEventEmitter({\n  addListener() {},\n  removeListeners() {},\n});\n\nexport function withSubscription(WrappedComponent: React.FC<object>): React.Component<object> {\n  class LogBoxStateSubscription extends React.Component<React.PropsWithChildren<Props>, State> {\n    static getDerivedStateFromError() {\n      return { hasError: true };\n    }\n\n    constructor(props) {\n      super(props);\n\n      if (process.env.NODE_ENV === 'development') {\n        emitter.addListener('devLoadingView:hide', () => {\n          if (this.state.hasError) {\n            this.retry();\n          }\n        });\n      }\n    }\n\n    componentDidCatch(err: Error, errorInfo: { componentStack: string } & any) {\n      /* $FlowFixMe[class-object-subtyping] added when improving typing for\n       * this parameters */\n      reportLogBoxError(err, errorInfo.componentStack);\n    }\n\n    _subscription?: Subscription;\n\n    state = {\n      logs: new Set<LogBoxLog>(),\n      isDisabled: false,\n      hasError: false,\n      selectedLogIndex: -1,\n    };\n\n    retry = () => {\n      return new Promise<void>((resolve) => {\n        this.setState({ hasError: false }, () => {\n          resolve();\n        });\n      });\n    };\n\n    render() {\n      return (\n        <LogContext.Provider\n          value={{\n            selectedLogIndex: this.state.selectedLogIndex,\n            isDisabled: this.state.isDisabled,\n            logs: Array.from(this.state.logs),\n          }}>\n          {this.state.hasError ? null : this.props.children}\n          <WrappedComponent />\n        </LogContext.Provider>\n      );\n    }\n\n    componentDidMount(): void {\n      this._subscription = observe((data) => {\n        // Ignore the initial empty log\n        if (data.selectedLogIndex === -1) return;\n        React.startTransition(() => {\n          this.setState(data);\n        });\n      });\n    }\n\n    componentWillUnmount(): void {\n      if (this._subscription != null) {\n        this._subscription.unsubscribe();\n      }\n    }\n\n    _handleDismiss = (): void => {\n      // Here we handle the cases when the log is dismissed and it\n      // was either the last log, or when the current index\n      // is now outside the bounds of the log array.\n      const { selectedLogIndex, logs: stateLogs } = this.state;\n      const logsArray = Array.from(stateLogs);\n      if (selectedLogIndex != null) {\n        if (logsArray.length - 1 <= 0) {\n          setSelectedLog(-1);\n        } else if (selectedLogIndex >= logsArray.length - 1) {\n          setSelectedLog(selectedLogIndex - 1);\n        }\n\n        dismiss(logsArray[selectedLogIndex]);\n      }\n    };\n\n    _handleMinimize = (): void => {\n      setSelectedLog(-1);\n    };\n\n    _handleSetSelectedLog = (index: number): void => {\n      setSelectedLog(index);\n    };\n  }\n\n  // @ts-expect-error\n  return LogBoxStateSubscription;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}